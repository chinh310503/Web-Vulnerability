# Command injection
## Command injection là gì
Việc tiêm lệnh hệ điều hành còn được gọi là tiêm shell. Nó cho phép kẻ tấn công thực thi các lệnh của hệ điều hành (OS) trên máy chủ đang chạy ứng dụng và thường xâm phạm hoàn toàn ứng dụng và dữ liệu của nó. Thông thường, kẻ tấn công có thể lợi dụng lỗ hổng chèn lệnh của hệ điều hành để xâm phạm các phần khác của cơ sở hạ tầng lưu trữ và khai thác các mối quan hệ tin cậy để chuyển cuộc tấn công sang các hệ thống khác trong tổ chức.

## Ví dụ đơn giản

Trong ví dụ này, một ứng dụng mua sắm cho phép người dùng xem liệu một mặt hàng có còn hàng ở một cửa hàng cụ thể hay không. Thông tin này được truy cập thông qua một URL:

`https://insecure-website.com/stockStatus?productID=381&storeID=29`

Để cung cấp thông tin chứng khoán, ứng dụng phải truy vấn các hệ thống cũ khác nhau. Vì lý do lịch sử, chức năng này được triển khai bằng cách gọi lệnh shell với ID sản phẩm và ID cửa hàng làm đối số:

`stockreport.pl 381 29`

Lệnh này xuất ra trạng thái tồn kho của mặt hàng được chỉ định và được trả về cho người dùng.

Ứng dụng không thực hiện biện pháp phòng vệ nào trước việc tiêm lệnh của hệ điều hành, vì vậy kẻ tấn công có thể gửi thông tin đầu vào sau để thực thi lệnh tùy ý:

`& echo aiwefwlguh &`

Nếu đầu vào này được gửi trong tham số `productID`, lệnh được ứng dụng thực thi là:

`stockreport.pl & echo aiwefwlguh & 29`

Lệnh `echo` làm cho chuỗi được cung cấp bị lặp lại ở đầu ra. Đây là một cách hữu ích để kiểm tra một số kiểu chèn lệnh của hệ điều hành. Ký tự `&` là dấu phân cách lệnh shell. Trong ví dụ này, nó khiến ba lệnh riêng biệt được thực thi lần lượt. Kết quả trả về cho người dùng là:

```
Error - productID was not provided
aiwefwlguh
29: command not found
```

Ba dòng đầu ra chứng minh rằng:

- Lệnh ban đầu `stockreport.pl` được thực thi mà không có đối số dự kiến ​​và do đó trả về thông báo lỗi.
- Lệnh được chèn `echo` đã được thực thi và chuỗi được cung cấp được lặp lại ở đầu ra.
- Đối số ban đầu `29` được thực thi dưới dạng lệnh và gây ra lỗi.

Việc đặt dấu phân cách lệnh bổ sung &sau lệnh được chèn rất hữu ích vì nó tách lệnh được chèn khỏi bất kỳ lệnh nào theo sau điểm chèn. Điều này làm giảm khả năng những gì xảy ra sau đó sẽ ngăn lệnh được chèn thực thi.

## Các lệnh hữu ích

**Hệ điều hành Linux**

- Tên của người dùng hiện tại	: whoami	
- Hệ điều hành	: uname -a	
- Cấu hình mạng	: ifconfig	
- Kết nối mạng	: netstat -an	
- Tiến trình đang chạy :	ps -ef

## 

  **Hệ điều hành Windows**

- Tên của người dùng hiện tại	:	whoami
- Hệ điều hành	:	ver
- Cấu hình mạng	:	ipconfig /all
- Kết nối mạng	:	netstat -an
- Tiến trình đang chạy	:	tasklist

## Các cách chèn lệnh 

- Sử dụng độ trễ thời gian
- Sử dụng chuyển hướng đầu ra
- Sử dụng kỹ thuật ngoài băng tần (OAST)

  ## Các ký tự shell hữu dụng
Một số ký tự có chức năng phân tách lệnh, cho phép các lệnh được xâu chuỗi lại với nhau. Các trình phân tách lệnh sau hoạt động trên cả hệ thống dựa trên Windows và Unix:
```
&
&&
|
||
```

Các dấu tách lệnh sau chỉ hoạt động trên các hệ thống dựa trên Unix:

- `;`
- Dòng mới ( `0x0a` hoặc `\n`)

Trên các hệ thống dựa trên Unix, bạn cũng có thể sử dụng backticks hoặc ký tự đô la để thực hiện thực thi nội tuyến lệnh được chèn trong lệnh gốc:
  
```  `lệnh được tiêm` ```

`$(lệnh được tiêm)`

## Cách ngăn chặn Command injection

Cách hiệu quả nhất để ngăn chặn các lỗ hổng chèn lệnh của hệ điều hành là không bao giờ gọi các lệnh của hệ điều hành từ mã lớp ứng dụng. Trong hầu hết các trường hợp, có nhiều cách khác nhau để triển khai chức năng được yêu cầu bằng cách sử dụng API nền tảng an toàn hơn.

Nếu bạn phải gọi các lệnh của hệ điều hành bằng đầu vào do người dùng cung cấp thì bạn phải thực hiện xác thực đầu vào mạnh mẽ. Một số ví dụ về xác nhận hiệu quả bao gồm:

- Xác thực dựa trên danh sách trắng các giá trị được phép.
- Xác thực rằng đầu vào là một số.
- Xác thực rằng đầu vào chỉ chứa các ký tự chữ và số, không có cú pháp hoặc khoảng trắng nào khác.
