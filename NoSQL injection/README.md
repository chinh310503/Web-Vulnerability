# NoSQL injection

## NoSQL injection là gì
NoSQL injection là một lỗ hổng mà kẻ tấn công có thể can thiệp vào các truy vấn mà ứng dụng thực hiện đối với cơ sở dữ liệu NoSQL. NoSQL injection có thể cho phép kẻ tấn công:

- Bỏ qua cơ chế xác thực hoặc bảo vệ.
- Trích xuất hoặc chỉnh sửa dữ liệu.
- Gây ra tình trạng từ chối dịch vụ.
- Thực thi mã trên máy chủ.
  
Cơ sở dữ liệu NoSQL lưu trữ và truy xuất dữ liệu theo định dạng khác với các bảng quan hệ SQL truyền thống. Chúng sử dụng nhiều ngôn ngữ truy vấn thay vì một chuẩn chung như SQL và có ít ràng buộc quan hệ hơn.

## NoSQL syntax injection

Bạn có thể phát hiện ra lỗ hổng NoSQL injection bằng cách cố gắng phá vỡ cú pháp truy vấn. Để thực hiện việc này, hãy kiểm tra từng đầu vào một cách có hệ thống bằng cách gửi các chuỗi fuzz và các ký tự đặc biệt kích hoạt lỗi cơ sở dữ liệu hoặc một số hành vi có thể phát hiện khác nếu chúng không được ứng dụng khử trùng hoặc lọc đầy đủ.

Nếu bạn biết ngôn ngữ API của cơ sở dữ liệu mục tiêu, hãy sử dụng các ký tự đặc biệt và chuỗi fuzz có liên quan đến ngôn ngữ đó. Nếu không, hãy sử dụng nhiều chuỗi fuzz khác nhau để nhắm mục tiêu đến nhiều ngôn ngữ API.

Các cách phát hiện lõi cú pháp trong NoSQL

- Xác định ký tự nào được xử lý
- Xác nhận hành vi có điều kiện
- Ghi đè các điều kiện hiện có

## NoSQL operator injection

Cơ sở dữ liệu NoSQL thường sử dụng toán tử truy vấn, cung cấp các cách để chỉ định các điều kiện mà dữ liệu phải đáp ứng để được đưa vào kết quả truy vấn. Ví dụ về toán tử truy vấn MongoDB bao gồm:

- $where- Phù hợp với các tài liệu thỏa mãn biểu thức JavaScript.
- $ne- Phù hợp với tất cả các giá trị không bằng một giá trị được chỉ định.
- $in- Phù hợp với tất cả các giá trị được chỉ định trong một mảng.
- $regex- Chọn các tài liệu có giá trị khớp với biểu thức chính quy đã chỉ định.

Bạn có thể chèn toán tử truy vấn để thao tác các truy vấn NoSQL. Để thực hiện việc này, hãy gửi các toán tử khác nhau một cách có hệ thống vào một loạt các đầu vào của người dùng, sau đó xem xét các phản hồi để tìm thông báo lỗi hoặc các thay đổi khác.

## Khai thác NoSQL syntax injection  để trích xuất dữ liệu

**Trích xuất dữ liệu trong MongoDB**

Hãy xem xét một ứng dụng dễ bị tấn công cho phép người dùng tra cứu tên người dùng đã đăng ký khác và hiển thị vai trò của họ. Điều này kích hoạt một yêu cầu đến URL:

`https://insecure-website.com/user/lookup?username=admin`

Điều này dẫn đến truy vấn NoSQL sau của bộ sưu tập `users`:

`{"$where":"this.username == 'admin'"}`

Vì truy vấn sử dụng toán tử $where, bạn có thể thử chèn các hàm JavaScript vào truy vấn này để nó trả về dữ liệu nhạy cảm. Ví dụ: bạn có thể gửi tải trọng sau:

`admin' && this.password[0] == 'a' || 'a'=='b`

Hàm này trả về ký tự đầu tiên trong chuỗi mật khẩu của người dùng, cho phép bạn trích xuất từng ký tự mật khẩu.

Bạn cũng có thể sử dụng hàm JavaScript `match()` để trích xuất thông tin. Ví dụ, tải trọng sau cho phép bạn xác định xem mật khẩu có chứa chữ số hay không:

`admin' && this.password.match(/\d/) || 'a'=='b`

**Xác định tên trường**

Vì MongoDB xử lý dữ liệu bán cấu trúc không yêu cầu lược đồ cố định nên bạn có thể cần xác định các trường hợp lệ trong bộ sưu tập trước khi có thể trích xuất dữ liệu bằng cách sử dụng JavaScript.

Ví dụ, để xác định xem cơ sở dữ liệu MongoDB có chứa passwordtrường nào không, bạn có thể gửi đoạn mã sau:

`https://insecure-website.com/user/lookup?username=admin'+%26%26+this.password!%3d'`

Gửi lại tải trọng cho một trường hiện có và cho một trường không tồn tại. Trong ví dụ này, bạn biết rằng trường username tồn tại, vì vậy bạn có thể gửi các tải trọng sau:

`admin' && this.username!=' admin' && this.foo!='`

Nếu trường password tồn tại, bạn sẽ mong đợi phản hồi giống hệt với phản hồi cho trường hiện có (username), nhưng khác với phản hồi cho trường không tồn tại (foo).

Nếu bạn muốn kiểm tra nhiều tên trường khác nhau, bạn có thể thực hiện tấn công từ điển bằng cách sử dụng danh sách từ để duyệt qua nhiều tên trường tiềm năng khác nhau.

## Khai thác NoSQL operator injection để trích xuất dữ liệu

**Chèn toán tử vào MongoDB**

Hãy xem xét một ứng dụng dễ bị tấn công chấp nhận tên người dùng và mật khẩu trong nội dung yêu cầu POST:

`{"username":"wiener","password":"peter"}`

Để kiểm tra xem bạn có thể chèn toán tử hay không, bạn có thể thử thêm toán tử $where làm tham số bổ sung, sau đó gửi một yêu cầu trong đó điều kiện được đánh giá là sai và một yêu cầu khác được đánh giá là đúng. Ví dụ:

`{"username":"wiener","password":"peter", "$where":"0"}{"username":"wiener","password":"peter", "$where":"1"}`

Nếu có sự khác biệt giữa các phản hồi, điều này có thể chỉ ra rằng biểu thức JavaScript trong mệnh đề $where đang được đánh giá.

**Trích xuất tên trường**

Nếu bạn đã chèn một toán tử cho phép bạn chạy JavaScript, bạn có thể sử dụng phương pháp `keys()` này để trích xuất tên của các trường dữ liệu. Ví dụ: bạn có thể gửi tải trọng sau:

`"$where":"Object.keys(this)[0].match('^.{0}a.*')"`

Điều này kiểm tra trường dữ liệu đầu tiên trong đối tượng người dùng và trả về ký tự đầu tiên của tên trường. Điều này cho phép bạn trích xuất tên trường theo từng ký tự.

**Trích xuất dữ liệu bằng cách sử dụng toán tử**
Ngoài ra, bạn có thể trích xuất dữ liệu bằng các toán tử không cho phép bạn chạy JavaScript. Ví dụ, bạn có thể sử dụng toán tử $regex để trích xuất dữ liệu theo từng ký tự.

Hãy xem xét một ứng dụng dễ bị tấn công chấp nhận tên người dùng và mật khẩu trong nội dung yêu cầu POST. Ví dụ:

`{"username":"myuser","password":"mypass"}`

Bạn có thể bắt đầu bằng cách kiểm tra xem toán tử $regex có được xử lý như sau không:

`{"username":"admin","password":{"$regex":"^.*"}}`

Nếu phản hồi cho yêu cầu này khác với phản hồi bạn nhận được khi bạn gửi mật khẩu không đúng, điều này cho biết ứng dụng có thể bị tấn công. Bạn có thể sử dụng toán tử 
 $regex để trích xuất dữ liệu theo từng ký tự. Ví dụ: tải trọng sau đây kiểm tra xem mật khẩu có bắt đầu bằng a:

`{"username":"admin","password":{"$regex":"^a*"}}`

## Tiêm dựa trên thời gian
Đôi khi việc kích hoạt lỗi cơ sở dữ liệu không gây ra sự khác biệt trong phản hồi của ứng dụng. Trong trường hợp này, bạn vẫn có thể phát hiện và khai thác lỗ hổng bằng cách sử dụng JavaScript injection để kích hoạt độ trễ thời gian có điều kiện.

Để thực hiện tiêm NoSQL dựa trên thời gian:

1. Tải trang nhiều lần để xác định thời gian tải cơ sở.
2. Chèn một tải trọng dựa trên thời gian vào đầu vào. Tải trọng dựa trên thời gian gây ra sự chậm trễ cố ý trong phản hồi khi được thực thi. Ví dụ, `{"$where": "sleep(5000)"}` gây ra sự chậm trễ cố ý là 5000 ms khi tiêm thành công.
3. Xác định xem phản hồi có tải chậm hơn không. Điều này cho thấy tiêm thành công.


Các tải trọng dựa trên thời gian sau đây sẽ kích hoạt độ trễ thời gian nếu mật khẩu bắt đầu bằng chữ cái `a`:

```
admin'+function(x){var waitTill = new Date(new Date().getTime() + 5000);while((x.password[0]==="a") && waitTill > new Date()){};}(this)+'
```

```
admin'+function(x){if(x.password[0]==="a"){sleep(5000)};}(this)+'
```

## Ngăn chặn NoSQL injection

Cách thích hợp để ngăn chặn các cuộc tấn công NoSQL injection phụ thuộc vào công nghệ NoSQL cụ thể đang sử dụng. Do đó, chúng tôi khuyên bạn nên đọc tài liệu bảo mật cho cơ sở dữ liệu NoSQL mà bạn lựa chọn. Tuy nhiên, các hướng dẫn chung sau đây cũng sẽ hữu ích:

- Xác thực thông tin đầu vào của người dùng bằng cách sử dụng danh sách các ký tự được chấp nhận.
- Chèn dữ liệu đầu vào của người dùng bằng các truy vấn có tham số thay vì nối dữ liệu đầu vào của người dùng trực tiếp vào truy vấn.
- Để ngăn chặn việc chèn lệnh điều hành, hãy áp dụng danh sách cho phép các khóa được chấp nhận.


